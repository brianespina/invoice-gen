package client

import (
	"database/sql"
	"fmt"
	"invoice-gen/timelog"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/huh"
)

type view int

const (
	normal view = iota
	details
	add
)

type Client struct {
	name  string
	email string
	rate  float32
	id    int
}

type ClientList struct {
	list *List
	view view
	db   *sql.DB
	form *huh.Form
}

func New(db *sql.DB) ClientList {
	//Initialize new Client list
	clientListInstance := ClientList{
		db: db,
		form: huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Client Name").
					Prompt("?").
					Key("name"),

				huh.NewInput().
					Title("Client Email").
					Prompt("?").
					Key("email"),
				huh.NewInput().
					Title("Client Rate").
					Prompt("?").
					Key("rate"),
			),
		),
		list: NewList(db),
	}

	return clientListInstance
}
func (l ClientList) Init() tea.Cmd {
	return l.form.Init()
}

func (l ClientList) View() string {
	switch l.view {
	case details:
		var s string
		client := l.list[l.cursor]
		s += fmt.Sprintf("%s\n", client.name)
		s += fmt.Sprintf("%s\n", client.email)
		s += fmt.Sprintf("%.1f\n\n", client.rate)
		t := timelog.InitTimeList()
		timelog.FilterLogs(&t, l.cursor)
		s += t.View()
		return s
	case add:
		if l.form.State == huh.StateCompleted {
			name := l.form.GetString("name")
			email := l.form.GetString("email")
			rate := l.form.GetString("rate")
			return fmt.Sprintf("You selected: %s, %s, %s", name, email, rate)
		}
		return l.form.View()
	case normal:
		fallthrough
	default:
		var s string
		for i, client := range l.list {
			cursor := " "
			if l.cursor == i {
				cursor = "|"
			}
			s += fmt.Sprintf("%s %s\n", cursor, client.name)
		}
		return s
	}
}

func (l ClientList) Update(msg tea.Msg) (ClientList, tea.Cmd) {
	switch l.view {
	case normal:
		listModel, cmd := l.list.Update(msg)
		return
	}

	return l, nil
}
